#Extract AMDR Archive

Add-Type -AssemblyName System.Windows.Forms
Add-Type -AssemblyName System.Drawing

<################ Change output file path here ####################>

$outputfile = "H:\Pages\feed files\cr_portia_portfolio.txt"
$outputpath = "H:\"

# store name of the file to be read from AMDR 1-year Archive
# file is filtered by size (greater than ~2MB) and sorted by last modified time
$crportfile = [string]
$crportfile = @(get-childitem "\\Mlisrchive" -filter *_cr_portia_portfolio.txt |
        where-object {$_.Length -gt 2000000} | sort -property LastWriteTime -descending | 
        select -first 1 -expandproperty name)

 $inputfile = "\\Mlidrarchive\$crportfile"
    
<##################################################################>

    
# Set the size of your form
$Form = New-Object System.Windows.Forms.Form
$Form.width = 500
$Form.height = 300
$Form.Text = ‚ÄùMy Cheesy Form with Radio buttons"
 
# Set the font of the text to be used within the form
$Font = New-Object System.Drawing.Font("Times New Roman",12)
$Form.Font = $Font
 
# Create a group that will contain your radio buttons
$MyGroupBox = New-Object System.Windows.Forms.GroupBox
$MyGroupBox.Location = '40,30'
$MyGroupBox.size = '400,150'
$MyGroupBox.text = "Do you like Cheese?"
    
# Create the collection of radio buttons
$RadioButton1 = New-Object System.Windows.Forms.RadioButton
$RadioButton1.Location = '20,40'
$RadioButton1.size = '350,20'
$RadioButton1.Checked = $true 
$RadioButton1.Text = "Yes - I like Cheese."
 
$RadioButton2 = New-Object System.Windows.Forms.RadioButton
$RadioButton2.Location = '20,70'
$RadioButton2.size = '350,20'
$RadioButton2.Checked = $false
$RadioButton2.Text = "No - I don't like Cheese."
 
$RadioButton3 = New-Object System.Windows.Forms.RadioButton
$RadioButton3.Location = '20,100'
$RadioButton3.size = '350,20'
$RadioButton3.Checked = $false
$RadioButton3.Text = "Sometimes - Depending on the type of cheese."
 
# Add an OK button
# Thanks to J.Vierra for simplifing the use of buttons in forms
$OKButton = new-object System.Windows.Forms.Button
$OKButton.Location = '130,200'
$OKButton.Size = '100,40' 
$OKButton.Text = 'OK'
$OKButton.DialogResult=[System.Windows.Forms.DialogResult]::OK
 
#Add a cancel button
$CancelButton = new-object System.Windows.Forms.Button
$CancelButton.Location = '255,200'
$CancelButton.Size = '100,40'
$CancelButton.Text = "Cancel"
$CancelButton.DialogResult=[System.Windows.Forms.DialogResult]::Cancel
 
# Add all the Form controls on one line 
$form.Controls.AddRange(@($MyGroupBox,$OKButton,$CancelButton))
 
# Add all the GroupBox controls on one line
$MyGroupBox.Controls.AddRange(@($Radiobutton1,$RadioButton2,$RadioButton3))
    
# Assign the Accept and Cancel options in the form to the corresponding buttons
$form.AcceptButton = $OKButton
$form.CancelButton = $CancelButton
 
# Activate the form
$form.Add_Shown({$form.Activate()})    
    
# Get the results from the button click
$dialogResult = $form.ShowDialog()
 
function Extract-AMDR([string]$inputfile, [string]$outputfile) {

    # store user input in x for validation
    $x = "TOR200,   TORTHH915" #$textbox.text

    # input must contains only letters, numbers, commas or spaces and less than 200 in length
    # if input is invalid, user can choose to try again or stop the script
    while($x -match "[^a-zA-Z0-9, ]" -or $x.Length -gt 200) {
         
         # display message when input is invalid
         $form.add_shown({$textbox.select()})
         $message.Text = "Error - Your input contains invalid characters or exceeds 200 characters" 
         $message.ForeColor = "Red"
     
         # retry 
         $result = $form.showdialog() 
         $x = $textbox.text

         # user choose 'cancel' to stop script
         if ($result -eq [system.windows.forms.dialogresult]::cancel) {
            exit 0
         }
    } 

    # process user's input string to components
    $portcodes = @()
    $portcodes = $x.split("{,}").trim() #split string and trim trailing spaces

    #$form.controls.add($message)

    <# read the header row and store into output file. This will replace
    the file if one already existed #>
    get-content $inputfile | select -first 1 | out-file -Encoding ascii -filepath $outputfile

    <# for each item in user's input, find matches row in the archive file  
    and append to the newly created feed file #>
    foreach ($item in $portcodes) {
        $result = @(get-content $inputfile | where-object{($_ -match $item)} |
         select -First 1 | out-file -append -Encoding ascii -filepath $outputfile)
    }

    # open the file
    invoke-item -path $outputfile

    $message.Text = "cr_portia_portfolio.txt has been generated `n`nOutput location: $outputfile"
    $textbox.text = "" 
}

# If the OK button is selected
if ($dialogResult -eq "OK"){
        
    # Check the current state of each radio button and respond accordingly
    if ($RadioButton1.Checked){
        Extract-AMDR($inputfile, 
        [System.Windows.Forms.MessageBox]::Show("Radio1")}
    elseif ($RadioButton2.Checked){
        [System.Windows.Forms.MessageBox]::Show("Radio2")}
    elseif ($RadioButton3.Checked){
        [System.Windows.Forms.MessageBox]::Show("Radio3")}
}

#

#$form.ShowDialog()
 
# Call the function

